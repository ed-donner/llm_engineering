"""
Token Guessing Game - Day 4

Interactive game where players guess words/phrases with token IDs close to a target.
Uses tiktoken for tokenization and Ollama for generating hints.
"""

import tiktoken
from openai import OpenAI
from typing import Optional, Dict, List


class TokenGuessingGame:
    """Main game class for the token guessing game."""
    
    def __init__(self, model: str = "llama3.1", base_url: str = "http://localhost:11434/v1"):
        """
        Initialize the game.
        
        Args:
            model: Ollama model to use for hints (default: "llama3.1")
            base_url: Base URL for Ollama API (default: "http://localhost:11434/v1")
        """
        self.model = model
        self.ollama = OpenAI(base_url=base_url, api_key='ollama')
        self.encoding = tiktoken.encoding_for_model("gpt-4.1-mini")
        self.target_token = None
        self.max_turns = None
        self.turns_taken = 0
        self.guessed_correctly = False
        self.guesses_history = []
    
    def get_token_id(self, text: str) -> Optional[int]:
        """
        Get the token ID for a given text.
        If the text has multiple tokens, returns the first token ID.
        
        Args:
            text: The text to tokenize
        
        Returns:
            The first token ID, or None if empty
        """
        if not text or not text.strip():
            return None
        
        tokens = self.encoding.encode(text.strip())
        if len(tokens) > 0:
            return tokens[0]  # Return first token ID
        return None
    
    def generate_hint(self, target_token: int, current_guess_token: int, turn: int, max_turns: int) -> str:
        """
        Generate a helpful hint using Ollama to guide the user.
        
        Args:
            target_token: The target token ID to guess
            current_guess_token: The token ID of the current guess
            turn: Current turn number
            max_turns: Maximum number of turns
        
        Returns:
            A hint string generated by Ollama
        """
        # Determine if we need to go higher or lower
        if current_guess_token < target_token:
            direction = "higher"
            difference = target_token - current_guess_token
        elif current_guess_token > target_token:
            direction = "lower"
            difference = current_guess_token - target_token
        else:
            return "ğŸ‰ You got it exactly right!"
        
        # Convert token IDs to text before sending to Ollama
        target_text = self.get_token_text(target_token)
        current_guess_text = self.get_token_text(current_guess_token)
        
        # Create a prompt for Ollama to generate a hint
        prompt = f"""You are helping someone play a token guessing game. 
The player is trying to guess a word or phrase. The target word is "{target_text}".
The player just guessed "{current_guess_text}". This is turn {turn} out of {max_turns}.

Generate a creative, helpful hint that suggests a word that might be closer to "{target_text}".
The hint should be like a riddle or question, such as:
- "What is the capital of France?"
- "What color is the sky?"
- "What do you call a baby cat?"

Make it fun and engaging! Just return the hint question, nothing else."""

        try:
            response = self.ollama.chat.completions.create(
                model=self.model,
                messages=[{"role": "user", "content": prompt}],
                temperature=0.7
            )
            return response.choices[0].message.content.strip()
        except Exception as e:
            # Fallback hint if Ollama fails
            if direction == "higher":
                return f"ğŸ’¡ Hint: Try a word that might have a higher token ID. Think of common words!"
            else:
                return f"ğŸ’¡ Hint: Try a word that might have a lower token ID. Think of simpler or shorter words!"
    
    def process_guess(self, guess: str) -> Dict:
        """
        Process a user's guess and return feedback.
        
        Args:
            guess: The user's guess (word or phrase)
        
        Returns:
            Dictionary with feedback information
        """
        if not guess or not guess.strip():
            return {
                "valid": False,
                "message": "Please enter a valid guess!"
            }
        
        # Get token ID of the guess
        guess_token = self.get_token_id(guess)
        
        if guess_token is None:
            return {
                "valid": False,
                "message": "Could not tokenize your input. Please try again with a valid word or phrase."
            }
        
        # Compare with target
        difference = abs(guess_token - self.target_token)
        
        result = {
            "valid": True,
            "guess": guess,
            "guess_token": guess_token,
            "target_token": self.target_token,
            "difference": difference,
            "won": False,
            "very_close": False
        }
        
        if guess_token == self.target_token:
            result["won"] = True
            result["message"] = "ğŸ‰ğŸ‰ğŸ‰ EXACT MATCH! You win! ğŸ‰ğŸ‰ğŸ‰"
        elif difference <= 5:
            result["very_close"] = True
            if guess_token < self.target_token:
                result["message"] = f"ğŸ”¥ VERY CLOSE! You're only {difference} away!\n   '{guess}' has token ID {guess_token}, which is LESS than the target {self.target_token}.\n   Try a word with a slightly higher token ID!"
            else:
                result["message"] = f"ğŸ”¥ VERY CLOSE! You're only {difference} away!\n   '{guess}' has token ID {guess_token}, which is GREATER than the target {self.target_token}.\n   Try a word with a slightly lower token ID!"
        elif guess_token < self.target_token:
            result["message"] = f"ğŸ“Š Your guess is LOWER than the target.\n   '{guess}' has token ID {guess_token}, which is {self.target_token - guess_token} less than the target {self.target_token}.\n   Try a word with a higher token ID!"
        else:
            result["message"] = f"ğŸ“Š Your guess is HIGHER than the target.\n   '{guess}' has token ID {guess_token}, which is {guess_token - self.target_token} more than the target {self.target_token}.\n   Try a word with a lower token ID!"
        
        return result
    
        """
        Main game handler function that runs the complete game.
        
        Args:
            target_token: The target token ID to guess
            max_turns: Maximum number of turns allowed
            input_func: Optional function to get user input (defaults to built-in input)
        """
        self.target_token = target_token
        self.max_turns = max_turns
        self.turns_taken = 0
        self.guessed_correctly = False
        self.guesses_history = []
        
        # Use provided input function or default to built-in input
        if input_func is None:
            input_func = input
        
        print("=" * 60)
        print("TOKEN GUESSING GAME")
        print("=" * 60)
        print()
        print(f"ğŸ”§ Tokenizer: tiktoken")
        print(f"ğŸ“¦ Model: gpt-4.1-mini (same as Day 4)")
        print()
        print(f"Target token ID: {target_token}")
        print(f"Maximum turns: {max_turns}")
        print()
        print("=" * 60)
        print(f"Game starting! Try to guess a word with token ID close to {target_token}")
        print("=" * 60)
        print()
        
        # Main game loop
        while self.turns_taken < self.max_turns and not self.guessed_correctly:
            # Check if we have any turns left before starting a new turn
            if self.turns_taken >= self.max_turns:
                break
            
            self.turns_taken += 1
            print(f"\n--- Turn {self.turns_taken}/{self.max_turns} ---")
            
            # Get user's guess
            try:
                guess = input_func("Enter your guess (word or phrase): ").strip()
            except (EOFError, KeyboardInterrupt):
                print("\n\nGame interrupted by user.")
                break
            
            # Process the guess
            result = self.process_guess(guess)
            
            if not result["valid"]:
                print(result["message"])
                self.turns_taken -= 1  # Don't count invalid guesses
                # Ensure turns_taken doesn't go negative
                if self.turns_taken < 0:
                    self.turns_taken = 0
                continue
            
            # Display guess information
            print(f"\nYour guess: '{result['guess']}'")
            print(f"Token ID of your guess: {result['guess_token']}")
            print(f"Target token ID: {result['target_token']}")
            print(f"\n{result['message']}")
            
            # Check if won
            if result["won"]:
                self.guessed_correctly = True
            
            # Store guess in history
            self.guesses_history.append({
                "turn": self.turns_taken,
                "guess": result["guess"],
                "token_id": result["guess_token"],
                "difference": result["difference"]
            })
            
            # Generate and display hint (unless they won)
            if not self.guessed_correctly and self.turns_taken < self.max_turns:
                print("\n" + "=" * 60)
                print("ğŸ¤– AI Hint:")
                hint = self.generate_hint(
                    self.target_token,
                    result["guess_token"],
                    self.turns_taken,
                    self.max_turns
                )
                print(hint)
                print("=" * 60)
            
            # Show progress
            if not self.guessed_correctly:
                remaining = self.max_turns - self.turns_taken
                print(f"\nTurns remaining: {remaining}")
                
                # Check if turns are exhausted after this turn
                if self.turns_taken >= self.max_turns:
                    print("\nğŸ˜” You've run out of turns!")
                    break
        
        # Display final results
        self.display_results()
    
    def get_token_text(self, token_id: int) -> str:
        """
        Get the text representation of a token ID.
        
        Args:
            token_id: The token ID to decode
        
        Returns:
            The text representation of the token
        """
        try:
            text = self.encoding.decode([token_id])
            return text
        except Exception as e:
            return f"[Unable to decode token {token_id}]"
    
    def select_word_from_domain(self) -> Dict:
        """
        Ask Ollama to select a word from a domain (geography, cities, countries, etc.)
        and return the token ID, domain, and initial hint.
        
        Returns:
            Dictionary with 'token_id', 'domain', 'hint', and 'word' (for internal use)
        """
        domains = [
            "geography (cities, countries, landmarks)",
            "animals (common animals, pets, wildlife)",
            "food (fruits, vegetables, dishes)",
            "colors",
            "nature (trees, flowers, natural phenomena)",
            "technology (devices, software, concepts)",
            "sports",
            "music (instruments, genres, artists)"
        ]
        
        import random
        selected_domain = random.choice(domains)
        
        prompt = f"""Select a single, common word from the domain: {selected_domain}.
        The word should be:
        - A single word (not a phrase)
        - Common and well-known
        - Appropriate for a guessing game
        - Between 3-10 letters long

        Return ONLY the word, nothing else. Just the word itself."""

        try:
            response = self.ollama.chat.completions.create(
                model=self.model,
                messages=[{"role": "user", "content": prompt}],
                temperature=0.8
            )
            word = response.choices[0].message.content.strip()
            # Clean up the word (remove quotes, extra text, etc.)
            word = word.strip('"\'.,!?;:')
            word = word.split()[0] if word.split() else word
            
            # Get token ID for the word
            token_id = self.get_token_id(word)
            
            if token_id is None:
                # Fallback to a default word
                word = "paris"
                token_id = self.get_token_id(word)
            
            # Generate an initial hint about the word
            hint_prompt = f"""Generate a creative, engaging hint for a word guessing game.
        The word is: {word}
        The domain is: {selected_domain}

        Create a hint that is like a riddle or question, such as:
        - "What is the capital of France?"
        - "What color is the sky?"
        - "What do you call a baby cat?"

        Make it fun and engaging! Just return the hint question, nothing else."""

            hint_response = self.ollama.chat.completions.create(
                model=self.model,
                messages=[{"role": "user", "content": hint_prompt}],
                temperature=0.7
            )
            hint = hint_response.choices[0].message.content.strip()
            
            return {
                "token_id": token_id,
                "domain": selected_domain,
                "hint": hint,
                "word": word  # For internal use only, not shown to player
            }
        except Exception as e:
            # Fallback to a default word
            word = "paris"
            token_id = self.get_token_id(word)
            return {
                "token_id": token_id,
                "domain": "geography (cities, countries, landmarks)",
                "hint": "What is the capital of France?",
                "word": word
            }
    
    def display_results(self):
        """Display the final game results."""
        print("\n" + "=" * 60)
        print("GAME OVER!")
        print("=" * 60)
        
        if self.guessed_correctly:
            print("\nğŸ‰ CONGRATULATIONS! You won! ğŸ‰")
            print(f"You guessed correctly in {self.turns_taken} turn(s)!")
        else:
            print("\nğŸ˜” Game Over - You ran out of turns!")
            print(f"\n" + "=" * 60)
            print("ğŸ¯ THE ANSWER:")
            print("=" * 60)
            print(f"  Target Token ID: {self.target_token}")
            
            # Show the word that the token ID represents
            try:
                target_text = self.get_token_text(self.target_token)
                print(f"  The word was: '{target_text}'")
                print(f"\n  ğŸ’¡ Token ID {self.target_token} represents: '{target_text}'")
            except Exception as e:
                print(f"  (Could not decode token {self.target_token}: {e})")
            
            # Show closest guess
            if self.guesses_history:
                closest_guess = min(self.guesses_history, key=lambda x: x['difference'])
                print(f"\nğŸ“Š Your closest guess was:")
                print(f"  Word: '{closest_guess['guess']}'")
                print(f"  Token ID: {closest_guess['token_id']}")
                print(f"  Difference: {closest_guess['difference']} away from target")
            else:
                print("\nğŸ“Š No valid guesses were made.")
        
        # Display guess history
        print("\n" + "=" * 60)
        print("GUESS HISTORY:")
        print("=" * 60)
        if self.guesses_history:
            for entry in self.guesses_history:
                status = "ğŸ¯ EXACT!" if entry['difference'] == 0 else f"({entry['difference']} away)"
                print(f"Turn {entry['turn']}: '{entry['guess']}' â†’ Token ID: {entry['token_id']} {status}")
        else:
            print("No guesses were made.")
        
        print("\n" + "=" * 60)
        print("Thanks for playing!")
        print("=" * 60)


def make_guess(game_instance, guess: str):
    """
    Make a single guess in the game. Use this function in notebook cells for each turn.
    
    Args:
        game_instance: The TokenGuessingGame instance
        guess: The word or phrase to guess
    
    Returns:
        Dictionary with result information
    """
    if game_instance.guessed_correctly:
        print("ğŸ‰ You already won! The game is over.")
        return None
    
    # Check if turns are exhausted before starting a new turn
    if game_instance.turns_taken >= game_instance.max_turns:
        print("ğŸ˜” You've run out of turns!")
        game_instance.display_results()
        return None
    
    game_instance.turns_taken += 1
    print(f"\n--- Turn {game_instance.turns_taken}/{game_instance.max_turns} ---")
    
    # Process the guess
    result = game_instance.process_guess(guess)
    
    if not result["valid"]:
        print(result["message"])
        game_instance.turns_taken -= 1  # Don't count invalid guesses
        # Ensure turns_taken doesn't go negative
        if game_instance.turns_taken < 0:
            game_instance.turns_taken = 0
        return result
    
    # Display guess information
    print(f"\nYour guess: '{result['guess']}'")
    print(f"Token ID of your guess: {result['guess_token']}")
    print(f"Target token ID: {result['target_token']}")
    print(f"\n{result['message']}")
    
    # Check if won
    if result["won"]:
        game_instance.guessed_correctly = True
        game_instance.display_results()
        return result
    
    # Store guess in history
    game_instance.guesses_history.append({
        "turn": game_instance.turns_taken,
        "guess": result["guess"],
        "token_id": result["guess_token"],
        "difference": result["difference"]
    })
    
    # Generate and display hint (unless they won)
    if not game_instance.guessed_correctly and game_instance.turns_taken < game_instance.max_turns:
        print("\n" + "=" * 60)
        print("ğŸ¤– AI Hint:")
        hint = game_instance.generate_hint(
            game_instance.target_token,
            result["guess_token"],
            game_instance.turns_taken,
            game_instance.max_turns
        )
        print(hint)
        print("=" * 60)
    
    # Show progress
    if not game_instance.guessed_correctly:
        remaining = game_instance.max_turns - game_instance.turns_taken
        print(f"\nTurns remaining: {remaining}")
        
        # Check if turns are exhausted after this turn
        if game_instance.turns_taken >= game_instance.max_turns:
            print("\nğŸ˜” You've run out of turns!")
            game_instance.display_results()
            return None
    
    return result

